use ast::*;
use parse::*;
/*
%nonassoc prec_ifdangling_noelse
%nonassoc ELSE
%nonassoc prec_single_if
%nonassoc ":="
%left "|"
%left "&"
%nonassoc "=" "<>" "<" ">" "<=" ">="
%left "+" "-"
%left "*" "/"
%right UNARY_MINUS
*/
#[pub]
top_expr -> Expr
     = space* e:expr space* { e }

expr -> Expr
     = "for" space+ i:id space* ":=" space* s:expr space+ "to" space+ u:expr space+ "do" space+ e:expr { Expr::For(i, Box::new(s), Box::new(u), Box::new(e)) }
     / "while" space+ c:expr space+ "do" space+ e:expr { Expr::Do(Box::new(c), Box::new(e)) }
     / expr0

expr0 -> Expr // if
      = "if" space* c:expr space* "then" space* e1:expr1 { Expr::IfNode(Box::new(c), Box::new(e1), Box::new(Expr::Nil)) }
      / expr1
expr1 -> Expr // ifelse
      = "if" space* c:expr space* "then" space* e1:expr2 space* "else" space* e2:expr2 { Expr::IfNode(Box::new(c), Box::new(e1), Box::new(e2)) }
      / expr2
expr2 -> Expr // :=
      = l:lvalue space* ":=" space* e:expr3 { Expr::LAsgn(l, Box::new(e)) }
      / expr3
expr3 -> Expr // "|"
      = e:expr4 ls:(space* "|" space* e:expr4 { (e, Op::Or) })* { fold_op(e, ls) }
expr4 -> Expr // "&"
      = e:expr5 ls:(space* "&" space* e:expr5 { (e, Op::And) })* { fold_op(e, ls) }
expr5 -> Expr // %nonassoc "=" "<>" "<" ">" "<=" ">="
      = e1:expr6 space* op:op5 space* e2:expr6 { Expr::OpNode(op, Box::new(e1), Box::new(e2)) }
      / expr6
op5 -> Op // %nonassoc "=" "<>" "<" ">" "<=" ">="
    = "=" { Op::Eq }
    / "<>" { Op::Ne }
    / "<=" { Op::Le }
    / ">=" { Op::Ge }
    / "<" { Op::Lt }
    / ">" { Op::Gt }
expr6 -> Expr // %left "+" "-"
      = e:expr7 ls:(space* o:op6 space* e:expr7 { (e, o) })* { fold_op(e, ls) }
      / expr7
op6 -> Op // %left "+" "-"
      = "+" { Op::Add }
      / "-" { Op::Sub }
expr7 -> Expr // %left "*" "/"
      = e:expr8 ls:(space* o:op7 space* e:expr8 { (e, o) })* { fold_op(e, ls) }
      / expr8
op7 -> Op // %left "*" "/"
      = "*" { Op::Mul }
      / "/" { Op::Div }
expr8 -> Expr // %right unary_minus
      = "-" space* e:expr8 { Expr::Neg(Box::new(e)) }
      / primary
primary -> Expr
     = "let" space+ decs:declaration_list space+ "in" space+ es:expr_seq_opt space+ "end" { Expr::Let(decs, Box::new(Expr::Seq(es))) }
     / string_constant
     / integer_constant
     / "nil" { Expr::Nil }
     / i:id space* "(" space* args:expr_list_opt space* ")" { Expr::FunApp(i, args) }
     / ty:id space* "{" space* ls:field_list_opt space* "}" { Expr::NewStruct(ty, ls) }
     / ty:id space* "[" space* n:expr space* "]" space* "of" space* e:expr
       { Expr::NewArray(ty, Box::new(n), Box::new(e)) }
     / "(" e:expr_seq_opt ")" { Expr::Seq(e) }
     / "break" { Expr::Break }
     / l:lvalue { Expr::LVal(l) }

expr_seq_opt -> Vec<Expr>
     = expr ++ (space* ";" space*)
     / { Vec::new() }

expr_list_opt -> Vec<Expr>
     = expr ++ (space* "," space*)
     / { Vec::new() }

field_list_opt -> Vec<Field>
     = (i:id space* "=" space* e:expr { Field::Field(i, Box::new(e)) }) ++ (space* "," space*)
     / { Vec::new() }

lvalue -> LValue
     = i:id { LValue::Id(i) } // not complete

declaration_list -> Vec<Dec>
     = declaration ++ (space*)
declaration -> Dec
     = "type" space+ id space* "=" space* type { panic!() }
     / "var" space+ i:id space* ty:(":" space* ty:id space* { ty })? ":=" space* e:expr { Dec::Var(i, ty, e) }
/*
fundec_space -> FunDec
        = f:fundec space* { f }
fundec -> FunDec
        = "def" space+ f:id space*
          "(" space* params:params space* ")" space* ":" space* ret_ty:type space*
          "{" space* e:exp space* "}" { {let mut t = params; t.reverse(); (f, t, ret_ty, e)} }
params -> Vec<(String, Type)>
        = x:id space* ":" space* ty:type space* "," space* params:params
          { {let mut t = params; t.push((x, ty)); t} }
        / x:id space* ":" space* ty:type { vec![(x, ty)] }
letex -> Expr
        = "let" space+ x:id space* "=" space* e1:exp space+ "in" space+ e2:exp
           { Expr::LetEx(x, Box::new(e1), Box::new(e2)) }
add_ast -> Expr
        = e:sum { super::vecast_to_ast(e, |op, l, r| Expr::OpNode(op, Box::new(l), Box::new(r))) }
sum -> (Vec<(Expr, Op)>, Expr)
	= l:mul_ast space* op:addop space* r:sum { {let (mut x, y) = r; x.push((l, op)); (x, y)} }
	/ e:mul_ast { (Vec::new(), e) }
addop -> Op
        = "+" { Op::Add }
        / "-" { Op::Sub }
mul_ast -> Expr
        = e:product { super::vecast_to_ast(e, |op, l, r| Expr::OpNode(op, Box::new(l), Box::new(r))) }
product -> (Vec<(Expr, Op)>, Expr)
	= l:atom space* op:mulop space* r:product { {let (mut x, y) = r; x.push((l, op)); (x, y)} }
	/ e:atom { (Vec::new(), e) }
mulop -> Op
        = "*" { Op::Mul }
        / "/" { Op::Div }
atom -> Expr
	= number
        / str
	/ "if" space* cond:exp space* "then" space* e1:exp space*
	"else" space* e2:exp space* "end"
	{ Expr::IfNode(Box::new(cond), Box::new(e1), Box::new(e2)) }
	/ v:id space* "(" space* e:args space* ")"
           { {let mut t = e; t.reverse(); Expr::FunApp(v, t)} }
        / v:id { Expr::Var(v) }
	/ "(" space* v:exp space* ")" { v }
args -> Vec<Expr>
        = e:exp space* "," space* a:args { {let mut t = a; t.push(e); t} }
        / e:exp { vec![e] }
*/
integer_constant -> Expr
	= [0-9]+ { Expr::Num(match_str.parse().unwrap()) }
string_constant -> Expr
        = "\"" s:str_internal "\"" { Expr::Str(s) }
str_internal -> String
        = [^\"]* { match_str.to_string() }
space -> ()
        = " " / "\n" / "\r"
id -> String
        = [a-zA-Z] [a-zA-Z0-9]* { match_str.to_string() }
type -> Type
        = "int" { Type::Int }
	/ "str" { Type::Str }
